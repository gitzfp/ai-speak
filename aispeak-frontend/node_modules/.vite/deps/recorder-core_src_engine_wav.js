// node_modules/recorder-core/src/engine/wav.js
(function() {
  "use strict";
  Recorder.prototype.enc_wav = {
    stable: true,
    fast: true,
    testmsg: "支持位数8位、16位（填在比特率里面），采样率取值无限制；此编码器仅在pcm数据前加了一个44字节的wav头，编码出来的16位wav文件去掉开头的44字节即可得到pcm（注：其他wav编码器可能不是44字节）"
  };
  Recorder.prototype.wav = function(res, True, False) {
    var This = this, set = This.set, size = res.length, sampleRate = set.sampleRate, bitRate = set.bitRate == 8 ? 8 : 16;
    var dataLength = size * (bitRate / 8);
    var buffer = new ArrayBuffer(44 + dataLength);
    var data = new DataView(buffer);
    var offset = 0;
    var writeString = function(str) {
      for (var i2 = 0; i2 < str.length; i2++, offset++) {
        data.setUint8(offset, str.charCodeAt(i2));
      }
      ;
    };
    var write16 = function(v) {
      data.setUint16(offset, v, true);
      offset += 2;
    };
    var write32 = function(v) {
      data.setUint32(offset, v, true);
      offset += 4;
    };
    writeString("RIFF");
    write32(36 + dataLength);
    writeString("WAVE");
    writeString("fmt ");
    write32(16);
    write16(1);
    write16(1);
    write32(sampleRate);
    write32(sampleRate * (bitRate / 8));
    write16(bitRate / 8);
    write16(bitRate);
    writeString("data");
    write32(dataLength);
    if (bitRate == 8) {
      for (var i = 0; i < size; i++, offset++) {
        var val = (res[i] >> 8) + 128;
        data.setInt8(offset, val, true);
      }
      ;
    } else {
      for (var i = 0; i < size; i++, offset += 2) {
        data.setInt16(offset, res[i], true);
      }
      ;
    }
    ;
    True(new Blob([data.buffer], { type: "audio/wav" }));
  };
})();
//# sourceMappingURL=recorder-core_src_engine_wav.js.map
