import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/recorder-core/src/recorder-core.js
var require_recorder_core = __commonJS({
  "node_modules/recorder-core/src/recorder-core.js"(exports, module) {
    (function(factory) {
      factory(window);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Recorder;
        });
      }
      ;
      if (typeof module == "object" && module.exports) {
        module.exports = Recorder;
      }
      ;
    })(function(window2) {
      "use strict";
      var NOOP = function() {
      };
      var Recorder2 = function(set) {
        return new initFn(set);
      };
      Recorder2.LM = "2023-07-01 20:46";
      var RecTxt = "Recorder";
      var getUserMediaTxt = "getUserMedia";
      var srcSampleRateTxt = "srcSampleRate";
      var sampleRateTxt = "sampleRate";
      var CatchTxt = "catch";
      Recorder2.IsOpen = function() {
        var stream = Recorder2.Stream;
        if (stream) {
          var tracks = stream.getTracks && stream.getTracks() || stream.audioTracks || [];
          var track = tracks[0];
          if (track) {
            var state = track.readyState;
            return state == "live" || state == track.LIVE;
          }
          ;
        }
        ;
        return false;
      };
      Recorder2.BufferSize = 4096;
      Recorder2.Destroy = function() {
        CLog(RecTxt + " Destroy");
        Disconnect();
        for (var k in DestroyList) {
          DestroyList[k]();
        }
        ;
      };
      var DestroyList = {};
      Recorder2.BindDestroy = function(key, call) {
        DestroyList[key] = call;
      };
      Recorder2.Support = function() {
        var scope = navigator.mediaDevices || {};
        if (!scope[getUserMediaTxt]) {
          scope = navigator;
          scope[getUserMediaTxt] || (scope[getUserMediaTxt] = scope.webkitGetUserMedia || scope.mozGetUserMedia || scope.msGetUserMedia);
        }
        ;
        if (!scope[getUserMediaTxt]) {
          return false;
        }
        ;
        Recorder2.Scope = scope;
        if (!Recorder2.GetContext()) {
          return false;
        }
        ;
        return true;
      };
      Recorder2.GetContext = function(tryNew) {
        var AC = window2.AudioContext;
        if (!AC) {
          AC = window2.webkitAudioContext;
        }
        ;
        if (!AC) {
          return null;
        }
        ;
        var ctx = Recorder2.Ctx;
        if (!ctx || ctx.state == "closed") {
          ctx = Recorder2.Ctx = new AC();
          Recorder2.NewCtxs = Recorder2.NewCtxs || [];
          Recorder2.BindDestroy("Ctx", function() {
            var ctx2 = Recorder2.Ctx;
            if (ctx2 && ctx2.close) {
              ctx2.close();
              Recorder2.Ctx = 0;
            }
            ;
            var arr = Recorder2.NewCtxs;
            Recorder2.NewCtxs = [];
            for (var i = 0; i < arr.length; i++)
              arr[i].close();
          });
        }
        ;
        if (tryNew && ctx.close) {
          try {
            ctx = new AC();
            Recorder2.NewCtxs.push(ctx);
          } catch (e) {
            CLog("GetContext tryNew异常", 1, e);
          }
        }
        ;
        return ctx;
      };
      Recorder2.CloseNewCtx = function(ctx) {
        if (ctx && ctx != Recorder2.Ctx) {
          ctx.close && ctx.close();
          var arr = Recorder2.NewCtxs || [], L = arr.length;
          for (var i = 0; i < arr.length; i++) {
            if (arr[i] == ctx) {
              arr.splice(i, 1);
              break;
            }
          }
          CLog("剩" + L + "-1=" + arr.length + "个GetContext未close", arr.length ? 3 : 0);
        }
      };
      var CtxState = function(ctx) {
        var v = ctx.state, msg = "ctx.state=" + v;
        if (v == "suspended")
          msg += "（注意：ctx不是running状态，rec.open和start至少要有一个在用户操作(触摸、点击等)时进行调用，否则将在rec.start时尝试进行ctx.resume，可能会产生兼容性问题(仅iOS)，请参阅文档中runningContext配置）";
        return msg;
      };
      var ConnectEnableWebM = "ConnectEnableWebM";
      Recorder2[ConnectEnableWebM] = true;
      var ConnectEnableWorklet = "ConnectEnableWorklet";
      Recorder2[ConnectEnableWorklet] = false;
      var Connect = function(streamStore, isUserMedia) {
        var bufferSize = streamStore.BufferSize || Recorder2.BufferSize;
        var stream = streamStore.Stream;
        var ctx = stream._RC || stream._c || Recorder2.GetContext(true);
        stream._c = ctx;
        var mediaConn = function(node) {
          var media = stream._m = ctx.createMediaStreamSource(stream);
          var ctxDest = ctx.destination, cmsdTxt = "createMediaStreamDestination";
          if (ctx[cmsdTxt]) {
            ctxDest = stream._d = ctx[cmsdTxt]();
          }
          ;
          media.connect(node);
          node.connect(ctxDest);
        };
        var isWebM, isWorklet, badInt, webMTips = "";
        var calls = stream._call;
        var onReceive = function(float32Arr) {
          for (var k0 in calls) {
            var size = float32Arr.length;
            var pcm = new Int16Array(size);
            var sum = 0;
            for (var j = 0; j < size; j++) {
              var s = Math.max(-1, Math.min(1, float32Arr[j]));
              s = s < 0 ? s * 32768 : s * 32767;
              pcm[j] = s;
              sum += Math.abs(s);
            }
            ;
            for (var k in calls) {
              calls[k](pcm, sum);
            }
            ;
            return;
          }
          ;
        };
        var scriptProcessor = "ScriptProcessor";
        var audioWorklet = "audioWorklet";
        var recAudioWorklet = RecTxt + " " + audioWorklet;
        var RecProc = "RecProc";
        var MediaRecorderTxt = "MediaRecorder";
        var MRWebMPCM = MediaRecorderTxt + ".WebM.PCM";
        var oldFn = ctx.createScriptProcessor || ctx.createJavaScriptNode;
        var oldIsBest = "。由于" + audioWorklet + "内部1秒375次回调，在移动端可能会有性能问题导致回调丢失录音变短，PC端无影响，暂不建议开启" + audioWorklet + "。";
        var oldScript = function() {
          isWorklet = stream.isWorklet = false;
          _Disconn_n(stream);
          CLog("Connect采用老的" + scriptProcessor + "，" + (Recorder2[ConnectEnableWorklet] ? "但已" : "可") + "设置" + RecTxt + "." + ConnectEnableWorklet + "=true尝试启用" + audioWorklet + webMTips + oldIsBest, 3);
          var process = stream._p = oldFn.call(ctx, bufferSize, 1, 1);
          mediaConn(process);
          process.onaudioprocess = function(e) {
            var arr = e.inputBuffer.getChannelData(0);
            onReceive(arr);
          };
        };
        var connWorklet = function() {
          isWebM = stream.isWebM = false;
          _Disconn_r(stream);
          isWorklet = stream.isWorklet = !oldFn || Recorder2[ConnectEnableWorklet];
          var AwNode = window2.AudioWorkletNode;
          if (!(isWorklet && ctx[audioWorklet] && AwNode)) {
            oldScript();
            return;
          }
          ;
          var clazzUrl = function() {
            var xf = function(f) {
              return f.toString().replace(/^function|DEL_/g, "").replace(/\$RA/g, recAudioWorklet);
            };
            var clazz = "class " + RecProc + " extends AudioWorkletProcessor{";
            clazz += "constructor " + xf(function(option) {
              DEL_super(option);
              var This = this, bufferSize2 = option.processorOptions.bufferSize;
              This.bufferSize = bufferSize2;
              This.buffer = new Float32Array(bufferSize2 * 2);
              This.pos = 0;
              This.port.onmessage = function(e) {
                if (e.data.kill) {
                  This.kill = true;
                  $C.log("$RA kill call");
                }
              };
              $C.log("$RA .ctor call", option);
            });
            clazz += "process " + xf(function(input, b, c) {
              var This = this, bufferSize2 = This.bufferSize;
              var buffer = This.buffer, pos = This.pos;
              input = (input[0] || [])[0] || [];
              if (input.length) {
                buffer.set(input, pos);
                pos += input.length;
                var len = ~~(pos / bufferSize2) * bufferSize2;
                if (len) {
                  this.port.postMessage({ val: buffer.slice(0, len) });
                  var more = buffer.subarray(len, pos);
                  buffer = new Float32Array(bufferSize2 * 2);
                  buffer.set(more);
                  pos = more.length;
                  This.buffer = buffer;
                }
                This.pos = pos;
              }
              return !This.kill;
            });
            clazz += '}try{registerProcessor("' + RecProc + '", ' + RecProc + ')}catch(e){$C.error("' + recAudioWorklet + '注册失败",e)}';
            clazz = clazz.replace(/\$C\./g, "console.");
            return "data:text/javascript;base64," + btoa(unescape(encodeURIComponent(clazz)));
          };
          var awNext = function() {
            return isWorklet && stream._na;
          };
          var nodeAlive = stream._na = function() {
            if (badInt !== "") {
              clearTimeout(badInt);
              badInt = setTimeout(function() {
                badInt = 0;
                if (awNext()) {
                  CLog(audioWorklet + "未返回任何音频，恢复使用" + scriptProcessor, 3);
                  oldFn && oldScript();
                }
                ;
              }, 500);
            }
            ;
          };
          var createNode = function() {
            if (!awNext())
              return;
            var node = stream._n = new AwNode(ctx, RecProc, {
              processorOptions: { bufferSize }
            });
            mediaConn(node);
            node.port.onmessage = function(e) {
              if (badInt) {
                clearTimeout(badInt);
                badInt = "";
              }
              ;
              if (awNext()) {
                onReceive(e.data.val);
              } else if (!isWorklet) {
                CLog(audioWorklet + "多余回调", 3);
              }
              ;
            };
            CLog("Connect采用" + audioWorklet + "，设置" + RecTxt + "." + ConnectEnableWorklet + "=false可恢复老式" + scriptProcessor + webMTips + oldIsBest, 3);
          };
          ctx.resume()[calls && "finally"](function() {
            if (!awNext())
              return;
            if (ctx[RecProc]) {
              createNode();
              return;
            }
            ;
            var url = clazzUrl();
            ctx[audioWorklet].addModule(url).then(function(e) {
              if (!awNext())
                return;
              ctx[RecProc] = 1;
              createNode();
              if (badInt) {
                nodeAlive();
              }
              ;
            })[CatchTxt](function(e) {
              CLog(audioWorklet + ".addModule失败", 1, e);
              awNext() && oldScript();
            });
          });
        };
        var connWebM = function() {
          var MR = window2[MediaRecorderTxt];
          var onData = "ondataavailable";
          var webmType = "audio/webm; codecs=pcm";
          isWebM = stream.isWebM = Recorder2[ConnectEnableWebM];
          var supportMR = MR && onData in MR.prototype && MR.isTypeSupported(webmType);
          webMTips = supportMR ? "" : "（此浏览器不支持" + MRWebMPCM + "）";
          if (!isUserMedia || !isWebM || !supportMR) {
            connWorklet();
            return;
          }
          var mrNext = function() {
            return isWebM && stream._ra;
          };
          var mrAlive = stream._ra = function() {
            if (badInt !== "") {
              clearTimeout(badInt);
              badInt = setTimeout(function() {
                if (mrNext()) {
                  CLog(MediaRecorderTxt + "未返回任何音频，降级使用" + audioWorklet, 3);
                  connWorklet();
                }
                ;
              }, 500);
            }
            ;
          };
          var mrSet = Object.assign({ mimeType: webmType }, Recorder2.ConnectWebMOptions);
          var mr = stream._r = new MR(stream, mrSet);
          var webmData = stream._rd = { sampleRate: ctx[sampleRateTxt] };
          mr[onData] = function(e) {
            var reader = new FileReader();
            reader.onloadend = function() {
              if (mrNext()) {
                var f32arr = WebM_Extract(new Uint8Array(reader.result), webmData);
                if (!f32arr)
                  return;
                if (f32arr == -1) {
                  connWorklet();
                  return;
                }
                ;
                if (badInt) {
                  clearTimeout(badInt);
                  badInt = "";
                }
                ;
                onReceive(f32arr);
              } else if (!isWebM) {
                CLog(MediaRecorderTxt + "多余回调", 3);
              }
              ;
            };
            reader.readAsArrayBuffer(e.data);
          };
          mr.start(~~(bufferSize / 48));
          CLog("Connect采用" + MRWebMPCM + "，设置" + RecTxt + "." + ConnectEnableWebM + "=false可恢复使用" + audioWorklet + "或老式" + scriptProcessor);
        };
        connWebM();
      };
      var ConnAlive = function(stream) {
        if (stream._na)
          stream._na();
        if (stream._ra)
          stream._ra();
      };
      var _Disconn_n = function(stream) {
        stream._na = null;
        if (stream._n) {
          stream._n.port.postMessage({ kill: true });
          stream._n.disconnect();
          stream._n = null;
        }
        ;
      };
      var _Disconn_r = function(stream) {
        stream._ra = null;
        if (stream._r) {
          stream._r.stop();
          stream._r = null;
        }
        ;
      };
      var Disconnect = function(streamStore) {
        streamStore = streamStore || Recorder2;
        var isGlobal = streamStore == Recorder2;
        var stream = streamStore.Stream;
        if (stream) {
          if (stream._m) {
            stream._m.disconnect();
            stream._m = null;
          }
          ;
          if (!stream._RC && stream._c) {
            Recorder2.CloseNewCtx(stream._c);
          }
          ;
          stream._RC = null;
          stream._c = null;
          if (stream._d) {
            StopS_(stream._d.stream);
            stream._d = null;
          }
          ;
          if (stream._p) {
            stream._p.disconnect();
            stream._p.onaudioprocess = stream._p = null;
          }
          ;
          _Disconn_n(stream);
          _Disconn_r(stream);
          if (isGlobal) {
            StopS_(stream);
          }
          ;
        }
        ;
        streamStore.Stream = 0;
      };
      var StopS_ = Recorder2.StopS_ = function(stream) {
        var tracks = stream.getTracks && stream.getTracks() || stream.audioTracks || [];
        for (var i = 0; i < tracks.length; i++) {
          var track = tracks[i];
          track.stop && track.stop();
        }
        ;
        stream.stop && stream.stop();
      };
      Recorder2.SampleData = function(pcmDatas, pcmSampleRate, newSampleRate, prevChunkInfo, option) {
        var Txt = "SampleData";
        prevChunkInfo || (prevChunkInfo = {});
        var index = prevChunkInfo.index || 0;
        var offset = prevChunkInfo.offset || 0;
        var filter = prevChunkInfo.filter;
        if (filter && filter.fn && filter.sr != pcmSampleRate) {
          filter = null;
          CLog(Txt + "的filter采样率变了，重设滤波", 3);
        }
        ;
        if (!filter) {
          var freq = newSampleRate > pcmSampleRate * 3 / 4 ? 0 : newSampleRate / 2 * 3 / 4;
          filter = { fn: freq ? Recorder2.IIRFilter(true, pcmSampleRate, freq) : 0 };
        }
        ;
        filter.sr = pcmSampleRate;
        var filterFn = filter.fn;
        var frameNext = prevChunkInfo.frameNext || [];
        option || (option = {});
        var frameSize = option.frameSize || 1;
        if (option.frameType) {
          frameSize = option.frameType == "mp3" ? 1152 : 1;
        }
        ;
        var nLen = pcmDatas.length;
        if (index > nLen + 1) {
          CLog(Txt + "似乎传入了未重置chunk " + index + ">" + nLen, 3);
        }
        ;
        var size = 0;
        for (var i = index; i < nLen; i++) {
          size += pcmDatas[i].length;
        }
        ;
        size = Math.max(0, size - Math.floor(offset));
        var step = pcmSampleRate / newSampleRate;
        if (step > 1) {
          size = Math.floor(size / step);
        } else {
          step = 1;
          newSampleRate = pcmSampleRate;
        }
        ;
        size += frameNext.length;
        var res = new Int16Array(size);
        var idx = 0;
        for (var i = 0; i < frameNext.length; i++) {
          res[idx] = frameNext[i];
          idx++;
        }
        ;
        for (; index < nLen; index++) {
          var o = pcmDatas[index];
          var i = offset, il = o.length;
          var F = filterFn && filterFn.Embed, F1 = 0, F2 = 0, Fx = 0, Fy = 0;
          for (var i0 = 0, i2 = 0; i0 < il; i0++, i2++) {
            if (i2 < il) {
              if (F) {
                Fx = o[i2];
                Fy = F.b0 * Fx + F.b1 * F.x1 + F.b0 * F.x2 - F.a1 * F.y1 - F.a2 * F.y2;
                F.x2 = F.x1;
                F.x1 = Fx;
                F.y2 = F.y1;
                F.y1 = Fy;
              } else {
                Fy = filterFn ? filterFn(o[i2]) : o[i2];
              }
            }
            F1 = F2;
            F2 = Fy;
            if (i2 == 0) {
              i0--;
              continue;
            }
            var before = Math.floor(i);
            if (i0 != before)
              continue;
            var after = Math.ceil(i);
            var atPoint = i - before;
            var beforeVal = F1;
            var afterVal = after < il ? F2 : beforeVal;
            res[idx] = beforeVal + (afterVal - beforeVal) * atPoint;
            idx++;
            i += step;
          }
          ;
          offset = Math.max(0, i - il);
        }
        ;
        frameNext = null;
        var frameNextSize = res.length % frameSize;
        if (frameNextSize > 0) {
          var u8Pos = (res.length - frameNextSize) * 2;
          frameNext = new Int16Array(res.buffer.slice(u8Pos));
          res = new Int16Array(res.buffer.slice(0, u8Pos));
        }
        ;
        return {
          index,
          offset,
          filter,
          frameNext,
          sampleRate: newSampleRate,
          data: res
        };
      };
      Recorder2.IIRFilter = function(useLowPass, sampleRate, freq) {
        var ov = 2 * Math.PI * freq / sampleRate;
        var sn = Math.sin(ov);
        var cs = Math.cos(ov);
        var alpha = sn / 2;
        var a0 = 1 + alpha;
        var a1 = -2 * cs / a0;
        var a2 = (1 - alpha) / a0;
        if (useLowPass) {
          var b0 = (1 - cs) / 2 / a0;
          var b1 = (1 - cs) / a0;
        } else {
          var b0 = (1 + cs) / 2 / a0;
          var b1 = -(1 + cs) / a0;
        }
        var x1 = 0, x2 = 0, y = 0, y1 = 0, y2 = 0;
        var fn = function(x) {
          y = b0 * x + b1 * x1 + b0 * x2 - a1 * y1 - a2 * y2;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
          return y;
        };
        fn.Embed = { x1: 0, x2: 0, y1: 0, y2: 0, b0, b1, a1, a2 };
        return fn;
      };
      Recorder2.PowerLevel = function(pcmAbsSum, pcmLength) {
        var power = pcmAbsSum / pcmLength || 0;
        var level;
        if (power < 1251) {
          level = Math.round(power / 1250 * 10);
        } else {
          level = Math.round(Math.min(100, Math.max(0, (1 + Math.log(power / 1e4) / Math.log(10)) * 100)));
        }
        ;
        return level;
      };
      Recorder2.PowerDBFS = function(maxSample) {
        var val = Math.max(0.1, maxSample || 0), Pref = 32767;
        val = Math.min(val, Pref);
        val = 20 * Math.log(val / Pref) / Math.log(10);
        return Math.max(-100, Math.round(val));
      };
      Recorder2.CLog = function(msg, err) {
        var now = new Date();
        var t = ("0" + now.getMinutes()).substr(-2) + ":" + ("0" + now.getSeconds()).substr(-2) + "." + ("00" + now.getMilliseconds()).substr(-3);
        var recID = this && this.envIn && this.envCheck && this.id;
        var arr = ["[" + t + " " + RecTxt + (recID ? ":" + recID : "") + "]" + msg];
        var a = arguments, console2 = window2.console || {};
        var i = 2, fn = console2.log;
        if (typeof err == "number") {
          fn = err == 1 ? console2.error : err == 3 ? console2.warn : fn;
        } else {
          i = 1;
        }
        ;
        for (; i < a.length; i++) {
          arr.push(a[i]);
        }
        ;
        if (IsLoser) {
          fn && fn("[IsLoser]" + arr[0], arr.length > 1 ? arr : "");
        } else {
          fn.apply(console2, arr);
        }
        ;
      };
      var CLog = function() {
        Recorder2.CLog.apply(this, arguments);
      };
      var IsLoser = true;
      try {
        IsLoser = !console.log.apply;
      } catch (e) {
      }
      ;
      var ID = 0;
      function initFn(set) {
        this.id = ++ID;
        Traffic();
        var o = {
          type: "mp3",
          bitRate: 16,
          sampleRate: 16e3,
          onProcess: NOOP
          //fn(buffers,powerLevel,bufferDuration,bufferSampleRate,newBufferIdx,asyncEnd) buffers=[[Int16,...],...]：缓冲的PCM数据，为从开始录音到现在的所有pcm片段；powerLevel：当前缓冲的音量级别0-100，bufferDuration：已缓冲时长，bufferSampleRate：缓冲使用的采样率（当type支持边录边转码(Worker)时，此采样率和设置的采样率相同，否则不一定相同）；newBufferIdx:本次回调新增的buffer起始索引；asyncEnd:fn() 如果onProcess是异步的(返回值为true时)，处理完成时需要调用此回调，如果不是异步的请忽略此参数，此方法回调时必须是真异步（不能真异步时需用setTimeout包裹）。onProcess返回值：如果返回true代表开启异步模式，在某些大量运算的场合异步是必须的，必须在异步处理完成时调用asyncEnd(不能真异步时需用setTimeout包裹)，在onProcess执行后新增的buffer会全部替换成空数组，因此本回调开头应立即将newBufferIdx到本次回调结尾位置的buffer全部保存到另外一个数组内，处理完成后写回buffers中本次回调的结尾位置。
          //*******高级设置******
          //,sourceStream:MediaStream Object
          //可选直接提供一个媒体流，从这个流中录制、实时处理音频数据（当前Recorder实例独享此流）；不提供时为普通的麦克风录音，由getUserMedia提供音频流（所有Recorder实例共享同一个流）
          //比如：audio、video标签dom节点的captureStream方法（实验特性，不同浏览器支持程度不高）返回的流；WebRTC中的remote流；自己创建的流等
          //注意：流内必须至少存在一条音轨(Audio Track)，比如audio标签必须等待到可以开始播放后才会有音轨，否则open会失败
          //,runningContext:AudioContext
          //可选提供一个state为running状态的AudioContext对象(ctx)；默认会在rec.open时自动创建一个新的ctx，无用户操作（触摸、点击等）时调用rec.open的ctx.state可能为suspended，会在rec.start时尝试进行ctx.resume，如果也无用户操作ctx.resume可能不会恢复成running状态（目前仅iOS上有此兼容性问题），导致无法去读取媒体流，这时请提前在用户操作时调用Recorder.GetContext(true)来得到一个running状态AudioContext（用完需调用CloseNewCtx(ctx)关闭）
          //,audioTrackSet:{ deviceId:"",groupId:"", autoGainControl:true, echoCancellation:true, noiseSuppression:true }
          //普通麦克风录音时getUserMedia方法的audio配置参数，比如指定设备id，回声消除、降噪开关；注意：提供的任何配置值都不一定会生效
          //由于麦克风是全局共享的，所以新配置后需要close掉以前的再重新open
          //更多参考: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints
          //,disableEnvInFix:false 内部参数，禁用设备卡顿时音频输入丢失补偿功能
          //,takeoffEncodeChunk:NOOP //fn(chunkBytes) chunkBytes=[Uint8,...]：实时编码环境下接管编码器输出，当编码器实时编码出一块有效的二进制音频数据时实时回调此方法；参数为二进制的Uint8Array，就是编码出来的音频数据片段，所有的chunkBytes拼接在一起即为完整音频。本实现的想法最初由QQ2543775048提出
          //当提供此回调方法时，将接管编码器的数据输出，编码器内部将放弃存储生成的音频数据；环境要求比较苛刻：如果当前环境不支持实时编码处理，将在open时直接走fail逻辑
          //因此提供此回调后调用stop方法将无法获得有效的音频数据，因为编码器内没有音频数据，因此stop时返回的blob将是一个字节长度为0的blob
          //目前只有mp3格式实现了实时编码，在支持实时处理的环境中将会实时的将编码出来的mp3片段通过此方法回调，所有的chunkBytes拼接到一起即为完整的mp3，此种拼接的结果比mock方法实时生成的音质更加，因为天然避免了首尾的静默
          //目前除mp3外其他格式不可以提供此回调，提供了将在open时直接走fail逻辑
        };
        for (var k in set) {
          o[k] = set[k];
        }
        ;
        this.set = o;
        this._S = 9;
        this.Sync = { O: 9, C: 9 };
      }
      ;
      Recorder2.Sync = {
        /*open*/
        O: 9,
        /*close*/
        C: 9
      };
      Recorder2.prototype = initFn.prototype = {
        CLog,
        _streamStore: function() {
          if (this.set.sourceStream) {
            return this;
          } else {
            return Recorder2;
          }
        },
        _streamCtx: function() {
          var m = this._streamStore().Stream;
          return m && m._c;
        },
        open: function(True, False) {
          var This = this, set = This.set, streamStore = This._streamStore(), newCtx = 0;
          True = True || NOOP;
          var failCall = function(errMsg, isUserNotAllow) {
            isUserNotAllow = !!isUserNotAllow;
            This.CLog("录音open失败：" + errMsg + ",isUserNotAllow:" + isUserNotAllow, 1);
            if (newCtx)
              Recorder2.CloseNewCtx(newCtx);
            False && False(errMsg, isUserNotAllow);
          };
          var ok = function() {
            This.CLog("open ok id:" + This.id);
            True();
            This._SO = 0;
          };
          var Lock = streamStore.Sync;
          var lockOpen = ++Lock.O, lockClose = Lock.C;
          This._O = This._O_ = lockOpen;
          This._SO = This._S;
          var lockFail = function() {
            if (lockClose != Lock.C || !This._O) {
              var err = "open被取消";
              if (lockOpen == Lock.O) {
                This.close();
              } else {
                err = "open被中断";
              }
              ;
              failCall(err);
              return true;
            }
            ;
          };
          var checkMsg = This.envCheck({ envName: "H5", canProcess: true });
          if (checkMsg) {
            failCall("不能录音：" + checkMsg);
            return;
          }
          ;
          if (set.sourceStream) {
            if (!Recorder2.GetContext()) {
              failCall("不支持此浏览器从流中获取录音");
              return;
            }
            ;
            Disconnect(streamStore);
            var stream = This.Stream = set.sourceStream;
            stream._RC = set.runningContext;
            stream._call = {};
            try {
              Connect(streamStore);
            } catch (e) {
              Disconnect(streamStore);
              failCall("从流中打开录音失败：" + e.message);
              return;
            }
            ok();
            return;
          }
          ;
          var codeFail = function(code, msg) {
            try {
              window2.top.a;
            } catch (e) {
              failCall('无权录音(跨域，请尝试给iframe添加麦克风访问策略，如allow="camera;microphone")');
              return;
            }
            ;
            if (/Permission|Allow/i.test(code)) {
              failCall("用户拒绝了录音权限", true);
            } else if (window2.isSecureContext === false) {
              failCall("浏览器禁止不安全页面录音，可开启https解决");
            } else if (/Found/i.test(code)) {
              failCall(msg + "，无可用麦克风");
            } else {
              failCall(msg);
            }
            ;
          };
          if (Recorder2.IsOpen()) {
            ok();
            return;
          }
          ;
          if (!Recorder2.Support()) {
            codeFail("", "此浏览器不支持录音");
            return;
          }
          ;
          var ctx = set.runningContext;
          if (!ctx)
            ctx = newCtx = Recorder2.GetContext(true);
          var f1 = function(stream2) {
            setTimeout(function() {
              stream2._call = {};
              var oldStream = Recorder2.Stream;
              if (oldStream) {
                Disconnect();
                stream2._call = oldStream._call;
              }
              ;
              Recorder2.Stream = stream2;
              stream2._c = ctx;
              stream2._RC = set.runningContext;
              if (lockFail())
                return;
              if (Recorder2.IsOpen()) {
                if (oldStream)
                  This.CLog("发现同时多次调用open", 1);
                Connect(streamStore, 1);
                ok();
              } else {
                failCall("录音功能无效：无音频流");
              }
              ;
            }, 100);
          };
          var f2 = function(e) {
            var code = e.name || e.message || e.code + ":" + e;
            This.CLog("请求录音权限错误", 1, e);
            codeFail(code, "无法录音：" + code);
          };
          var trackSet = set.audioTrackSet || {};
          trackSet[sampleRateTxt] = ctx[sampleRateTxt];
          var mSet = { audio: trackSet };
          try {
            var pro = Recorder2.Scope[getUserMediaTxt](mSet, f1, f2);
          } catch (e) {
            This.CLog(getUserMediaTxt, 3, e);
            mSet = { audio: true };
            pro = Recorder2.Scope[getUserMediaTxt](mSet, f1, f2);
          }
          ;
          This.CLog(getUserMediaTxt + "(" + JSON.stringify(mSet) + ") " + CtxState(ctx) + "，一般默认会降噪和回声消除，移动端可能会降低系统播放音量，请参阅文档中audioTrackSet配置");
          if (pro && pro.then) {
            pro.then(f1)[CatchTxt](f2);
          }
          ;
        },
        close: function(call) {
          call = call || NOOP;
          var This = this, streamStore = This._streamStore();
          This._stop();
          var Lock = streamStore.Sync;
          This._O = 0;
          if (This._O_ != Lock.O) {
            This.CLog("close被忽略（因为同时open了多个rec，只有最后一个会真正close）", 3);
            call();
            return;
          }
          ;
          Lock.C++;
          Disconnect(streamStore);
          This.CLog("close");
          call();
        },
        mock: function(pcmData, pcmSampleRate) {
          var This = this;
          This._stop();
          This.isMock = 1;
          This.mockEnvInfo = null;
          This.buffers = [pcmData];
          This.recSize = pcmData.length;
          This[srcSampleRateTxt] = pcmSampleRate;
          return This;
        },
        envCheck: function(envInfo) {
          var errMsg, This = this, set = This.set;
          var tag = "CPU_BE";
          if (!errMsg && !Recorder2[tag] && window2.Int8Array && !new Int8Array(new Int32Array([1]).buffer)[0]) {
            Traffic(tag);
            errMsg = "不支持" + tag + "架构";
          }
          ;
          if (!errMsg) {
            var type = set.type;
            if (This[type + "_envCheck"]) {
              errMsg = This[type + "_envCheck"](envInfo, set);
            } else {
              if (set.takeoffEncodeChunk) {
                errMsg = type + "类型" + (This[type] ? "" : "(未加载编码器)") + "不支持设置takeoffEncodeChunk";
              }
              ;
            }
            ;
          }
          ;
          return errMsg || "";
        },
        envStart: function(mockEnvInfo, sampleRate) {
          var This = this, set = This.set;
          This.isMock = mockEnvInfo ? 1 : 0;
          This.mockEnvInfo = mockEnvInfo;
          This.buffers = [];
          This.recSize = 0;
          This.envInLast = 0;
          This.envInFirst = 0;
          This.envInFix = 0;
          This.envInFixTs = [];
          var setSr = set[sampleRateTxt];
          if (setSr > sampleRate) {
            set[sampleRateTxt] = sampleRate;
          } else {
            setSr = 0;
          }
          This[srcSampleRateTxt] = sampleRate;
          This.CLog(srcSampleRateTxt + ": " + sampleRate + " set." + sampleRateTxt + ": " + set[sampleRateTxt] + (setSr ? " 忽略" + setSr : ""), setSr ? 3 : 0);
          This.engineCtx = 0;
          if (This[set.type + "_start"]) {
            var engineCtx = This.engineCtx = This[set.type + "_start"](set);
            if (engineCtx) {
              engineCtx.pcmDatas = [];
              engineCtx.pcmSize = 0;
            }
            ;
          }
          ;
        },
        envResume: function() {
          this.envInFixTs = [];
        },
        envIn: function(pcm, sum) {
          var This = this, set = This.set, engineCtx = This.engineCtx;
          var bufferSampleRate = This[srcSampleRateTxt];
          var size = pcm.length;
          var powerLevel = Recorder2.PowerLevel(sum, size);
          var buffers = This.buffers;
          var bufferFirstIdx = buffers.length;
          buffers.push(pcm);
          var buffersThis = buffers;
          var bufferFirstIdxThis = bufferFirstIdx;
          var now = Date.now();
          var pcmTime = Math.round(size / bufferSampleRate * 1e3);
          This.envInLast = now;
          if (This.buffers.length == 1) {
            This.envInFirst = now - pcmTime;
          }
          ;
          var envInFixTs = This.envInFixTs;
          envInFixTs.splice(0, 0, { t: now, d: pcmTime });
          var tsInStart = now, tsPcm = 0;
          for (var i = 0; i < envInFixTs.length; i++) {
            var o = envInFixTs[i];
            if (now - o.t > 3e3) {
              envInFixTs.length = i;
              break;
            }
            ;
            tsInStart = o.t;
            tsPcm += o.d;
          }
          ;
          var tsInPrev = envInFixTs[1];
          var tsIn = now - tsInStart;
          var lost = tsIn - tsPcm;
          if (lost > tsIn / 3 && (tsInPrev && tsIn > 1e3 || envInFixTs.length >= 6)) {
            var addTime = now - tsInPrev.t - pcmTime;
            if (addTime > pcmTime / 5) {
              var fixOpen = !set.disableEnvInFix;
              This.CLog("[" + now + "]" + (fixOpen ? "" : "未") + "补偿" + addTime + "ms", 3);
              This.envInFix += addTime;
              if (fixOpen) {
                var addPcm = new Int16Array(addTime * bufferSampleRate / 1e3);
                size += addPcm.length;
                buffers.push(addPcm);
              }
              ;
            }
            ;
          }
          ;
          var sizeOld = This.recSize, addSize = size;
          var bufferSize = sizeOld + addSize;
          This.recSize = bufferSize;
          if (engineCtx) {
            var chunkInfo = Recorder2.SampleData(buffers, bufferSampleRate, set[sampleRateTxt], engineCtx.chunkInfo);
            engineCtx.chunkInfo = chunkInfo;
            sizeOld = engineCtx.pcmSize;
            addSize = chunkInfo.data.length;
            bufferSize = sizeOld + addSize;
            engineCtx.pcmSize = bufferSize;
            buffers = engineCtx.pcmDatas;
            bufferFirstIdx = buffers.length;
            buffers.push(chunkInfo.data);
            bufferSampleRate = chunkInfo[sampleRateTxt];
          }
          ;
          var duration = Math.round(bufferSize / bufferSampleRate * 1e3);
          var bufferNextIdx = buffers.length;
          var bufferNextIdxThis = buffersThis.length;
          var asyncEnd = function() {
            var num = asyncBegin ? 0 : -addSize;
            var hasClear2 = buffers[0] == null;
            for (var i2 = bufferFirstIdx; i2 < bufferNextIdx; i2++) {
              var buffer = buffers[i2];
              if (buffer == null) {
                hasClear2 = 1;
              } else {
                num += buffer.length;
                if (engineCtx && buffer.length) {
                  This[set.type + "_encode"](engineCtx, buffer);
                }
                ;
              }
              ;
            }
            ;
            if (hasClear2 && engineCtx) {
              var i2 = bufferFirstIdxThis;
              if (buffersThis[0]) {
                i2 = 0;
              }
              ;
              for (; i2 < bufferNextIdxThis; i2++) {
                buffersThis[i2] = null;
              }
              ;
            }
            ;
            if (hasClear2) {
              num = asyncBegin ? addSize : 0;
              buffers[0] = null;
            }
            ;
            if (engineCtx) {
              engineCtx.pcmSize += num;
            } else {
              This.recSize += num;
            }
            ;
          };
          var asyncBegin = 0, procTxt = "rec.set.onProcess";
          try {
            asyncBegin = set.onProcess(buffers, powerLevel, duration, bufferSampleRate, bufferFirstIdx, asyncEnd);
          } catch (e) {
            console.error(procTxt + "回调出错是不允许的，需保证不会抛异常", e);
          }
          ;
          var slowT = Date.now() - now;
          if (slowT > 10 && This.envInFirst - now > 1e3) {
            This.CLog(procTxt + "低性能，耗时" + slowT + "ms", 3);
          }
          ;
          if (asyncBegin === true) {
            var hasClear = 0;
            for (var i = bufferFirstIdx; i < bufferNextIdx; i++) {
              if (buffers[i] == null) {
                hasClear = 1;
              } else {
                buffers[i] = new Int16Array(0);
              }
              ;
            }
            ;
            if (hasClear) {
              This.CLog("未进入异步前不能清除buffers", 3);
            } else {
              if (engineCtx) {
                engineCtx.pcmSize -= addSize;
              } else {
                This.recSize -= addSize;
              }
              ;
            }
            ;
          } else {
            asyncEnd();
          }
          ;
        },
        start: function() {
          var This = this;
          var isOpen = 1;
          if (This.set.sourceStream) {
            if (!This.Stream) {
              isOpen = 0;
            }
          } else if (!Recorder2.IsOpen()) {
            isOpen = 0;
          }
          ;
          if (!isOpen) {
            This.CLog("未open", 1);
            return;
          }
          ;
          var ctx = This._streamCtx();
          This.CLog("start 开始录音 " + CtxState(ctx));
          This._stop();
          This.state = 3;
          This.envStart(null, ctx[sampleRateTxt]);
          if (This._SO && This._SO + 1 != This._S) {
            This.CLog("start被中断", 3);
            return;
          }
          ;
          This._SO = 0;
          var end = function() {
            if (This.state == 3) {
              This.state = 1;
              This.resume();
            }
          };
          if (ctx.state == "suspended") {
            var tag = "AudioContext resume: ";
            This.CLog(tag + "wait...");
            ctx.resume().then(function() {
              This.CLog(tag + ctx.state);
              end();
            })[CatchTxt](function(e) {
              This.CLog(tag + ctx.state + " 可能无法录音：" + e.message, 1, e);
              end();
            });
          } else {
            end();
          }
          ;
        },
        pause: function() {
          var This = this;
          if (This.state) {
            This.state = 2;
            This.CLog("pause");
            delete This._streamStore().Stream._call[This.id];
          }
          ;
        },
        resume: function() {
          var This = this;
          if (This.state) {
            This.state = 1;
            This.CLog("resume");
            This.envResume();
            var stream = This._streamStore().Stream;
            stream._call[This.id] = function(pcm, sum) {
              if (This.state == 1) {
                This.envIn(pcm, sum);
              }
              ;
            };
            ConnAlive(stream);
          }
          ;
        },
        _stop: function(keepEngine) {
          var This = this, set = This.set;
          if (!This.isMock) {
            This._S++;
          }
          ;
          if (This.state) {
            This.pause();
            This.state = 0;
          }
          ;
          if (!keepEngine && This[set.type + "_stop"]) {
            This[set.type + "_stop"](This.engineCtx);
            This.engineCtx = 0;
          }
          ;
        },
        stop: function(True, False, autoClose) {
          var This = this, set = This.set, t1;
          var envInMS = This.envInLast - This.envInFirst, envInLen = envInMS && This.buffers.length;
          This.CLog("stop 和start时差" + (envInMS ? envInMS + "ms 补偿" + This.envInFix + "ms envIn:" + envInLen + " fps:" + (envInLen / envInMS * 1e3).toFixed(1) : "-") + " LM:" + Recorder2.LM);
          var end = function() {
            This._stop();
            if (autoClose) {
              This.close();
            }
            ;
          };
          var err = function(msg) {
            This.CLog("结束录音失败：" + msg, 1);
            False && False(msg);
            end();
          };
          var ok = function(blob, duration2) {
            This.CLog("结束录音 编码花" + (Date.now() - t1) + "ms 音频时长" + duration2 + "ms 文件大小" + blob.size + "b");
            if (set.takeoffEncodeChunk) {
              This.CLog("启用takeoffEncodeChunk后stop返回的blob长度为0不提供音频数据", 3);
            } else if (blob.size < Math.max(100, duration2 / 2)) {
              err("生成的" + set.type + "无效");
              return;
            }
            ;
            True && True(blob, duration2);
            end();
          };
          if (!This.isMock) {
            var isCtxWait = This.state == 3;
            if (!This.state || isCtxWait) {
              err("未开始录音" + (isCtxWait ? "，开始录音前无用户交互导致AudioContext未运行" : ""));
              return;
            }
            ;
            This._stop(true);
          }
          ;
          var size = This.recSize;
          if (!size) {
            err("未采集到录音");
            return;
          }
          ;
          if (!This.buffers[0]) {
            err("音频buffers被释放");
            return;
          }
          ;
          if (!This[set.type]) {
            err("未加载" + set.type + "编码器");
            return;
          }
          ;
          if (This.isMock) {
            var checkMsg = This.envCheck(This.mockEnvInfo || { envName: "mock", canProcess: false });
            if (checkMsg) {
              err("录音错误：" + checkMsg);
              return;
            }
            ;
          }
          ;
          var engineCtx = This.engineCtx;
          if (This[set.type + "_complete"] && engineCtx) {
            var duration = Math.round(engineCtx.pcmSize / set[sampleRateTxt] * 1e3);
            t1 = Date.now();
            This[set.type + "_complete"](engineCtx, function(blob) {
              ok(blob, duration);
            }, err);
            return;
          }
          ;
          t1 = Date.now();
          var chunk = Recorder2.SampleData(This.buffers, This[srcSampleRateTxt], set[sampleRateTxt]);
          set[sampleRateTxt] = chunk[sampleRateTxt];
          var res = chunk.data;
          var duration = Math.round(res.length / set[sampleRateTxt] * 1e3);
          This.CLog("采样" + size + "->" + res.length + " 花:" + (Date.now() - t1) + "ms");
          setTimeout(function() {
            t1 = Date.now();
            This[set.type](res, function(blob) {
              ok(blob, duration);
            }, function(msg) {
              err(msg);
            });
          });
        }
      };
      if (window2[RecTxt]) {
        CLog("重复引入" + RecTxt, 3);
        window2[RecTxt].Destroy();
      }
      ;
      window2[RecTxt] = Recorder2;
      var WebM_Extract = function(inBytes, scope) {
        if (!scope.pos) {
          scope.pos = [0];
          scope.tracks = {};
          scope.bytes = [];
        }
        ;
        var tracks = scope.tracks, position = [scope.pos[0]];
        var endPos = function() {
          scope.pos[0] = position[0];
        };
        var sBL = scope.bytes.length;
        var bytes = new Uint8Array(sBL + inBytes.length);
        bytes.set(scope.bytes);
        bytes.set(inBytes, sBL);
        scope.bytes = bytes;
        if (!scope._ht) {
          readMatroskaVInt(bytes, position);
          readMatroskaBlock(bytes, position);
          if (!BytesEq(readMatroskaVInt(bytes, position), [24, 83, 128, 103])) {
            return;
          }
          readMatroskaVInt(bytes, position);
          while (position[0] < bytes.length) {
            var eid0 = readMatroskaVInt(bytes, position);
            var bytes0 = readMatroskaBlock(bytes, position);
            var pos0 = [0], audioIdx = 0;
            if (!bytes0)
              return;
            if (BytesEq(eid0, [22, 84, 174, 107])) {
              while (pos0[0] < bytes0.length) {
                var eid1 = readMatroskaVInt(bytes0, pos0);
                var bytes1 = readMatroskaBlock(bytes0, pos0);
                var pos1 = [0], track = { channels: 0, sampleRate: 0 };
                if (BytesEq(eid1, [174])) {
                  while (pos1[0] < bytes1.length) {
                    var eid2 = readMatroskaVInt(bytes1, pos1);
                    var bytes2 = readMatroskaBlock(bytes1, pos1);
                    var pos2 = [0];
                    if (BytesEq(eid2, [215])) {
                      var val = BytesInt(bytes2);
                      track.number = val;
                      tracks[val] = track;
                    } else if (BytesEq(eid2, [131])) {
                      var val = BytesInt(bytes2);
                      if (val == 1)
                        track.type = "video";
                      else if (val == 2) {
                        track.type = "audio";
                        if (!audioIdx)
                          scope.track0 = track;
                        track.idx = audioIdx++;
                      } else
                        track.type = "Type-" + val;
                    } else if (BytesEq(eid2, [134])) {
                      var str = "";
                      for (var i = 0; i < bytes2.length; i++) {
                        str += String.fromCharCode(bytes2[i]);
                      }
                      track.codec = str;
                    } else if (BytesEq(eid2, [225])) {
                      while (pos2[0] < bytes2.length) {
                        var eid3 = readMatroskaVInt(bytes2, pos2);
                        var bytes3 = readMatroskaBlock(bytes2, pos2);
                        if (BytesEq(eid3, [181])) {
                          var val = 0, arr = new Uint8Array(bytes3.reverse()).buffer;
                          if (bytes3.length == 4)
                            val = new Float32Array(arr)[0];
                          else if (bytes3.length == 8)
                            val = new Float64Array(arr)[0];
                          else
                            CLog("WebM Track !Float", 1, bytes3);
                          track[sampleRateTxt] = Math.round(val);
                        } else if (BytesEq(eid3, [98, 100]))
                          track.bitDepth = BytesInt(bytes3);
                        else if (BytesEq(eid3, [159]))
                          track.channels = BytesInt(bytes3);
                      }
                    }
                  }
                }
              }
              ;
              scope._ht = 1;
              CLog("WebM Tracks", tracks);
              endPos();
              break;
            }
          }
        }
        var track0 = scope.track0;
        if (!track0)
          return;
        if (track0.bitDepth == 16 && /FLOAT/i.test(track0.codec)) {
          track0.bitDepth = 32;
          CLog("WebM 16改32位", 3);
        }
        if (track0[sampleRateTxt] != scope[sampleRateTxt] || track0.bitDepth != 32 || track0.channels < 1 || !/(\b|_)PCM\b/i.test(track0.codec)) {
          scope.bytes = [];
          if (!scope.bad)
            CLog("WebM Track非预期", 3, scope);
          scope.bad = 1;
          return -1;
        }
        var datas = [], dataLen = 0;
        while (position[0] < bytes.length) {
          var eid1 = readMatroskaVInt(bytes, position);
          var bytes1 = readMatroskaBlock(bytes, position);
          if (!bytes1)
            break;
          if (BytesEq(eid1, [163])) {
            var trackNo = bytes1[0] & 15;
            var track = tracks[trackNo];
            if (!track) {
              CLog("WebM !Track" + trackNo, 1, tracks);
            } else if (track.idx === 0) {
              var u8arr = new Uint8Array(bytes1.length - 4);
              for (var i = 4; i < bytes1.length; i++) {
                u8arr[i - 4] = bytes1[i];
              }
              datas.push(u8arr);
              dataLen += u8arr.length;
            }
          }
          endPos();
        }
        if (dataLen) {
          var more = new Uint8Array(bytes.length - scope.pos[0]);
          more.set(bytes.subarray(scope.pos[0]));
          scope.bytes = more;
          scope.pos[0] = 0;
          var u8arr = new Uint8Array(dataLen);
          for (var i = 0, i2 = 0; i < datas.length; i++) {
            u8arr.set(datas[i], i2);
            i2 += datas[i].length;
          }
          var arr = new Float32Array(u8arr.buffer);
          if (track0.channels > 1) {
            var arr2 = [];
            for (var i = 0; i < arr.length; ) {
              arr2.push(arr[i]);
              i += track0.channels;
            }
            arr = new Float32Array(arr2);
          }
          ;
          return arr;
        }
      };
      var BytesEq = function(bytes1, bytes2) {
        if (!bytes1 || bytes1.length != bytes2.length)
          return false;
        if (bytes1.length == 1)
          return bytes1[0] == bytes2[0];
        for (var i = 0; i < bytes1.length; i++) {
          if (bytes1[i] != bytes2[i])
            return false;
        }
        return true;
      };
      var BytesInt = function(bytes) {
        var s = "";
        for (var i = 0; i < bytes.length; i++) {
          var n = bytes[i];
          s += (n < 16 ? "0" : "") + n.toString(16);
        }
        ;
        return parseInt(s, 16) || 0;
      };
      var readMatroskaVInt = function(arr, pos, trim) {
        var i = pos[0];
        if (i >= arr.length)
          return;
        var b0 = arr[i], b2 = ("0000000" + b0.toString(2)).substr(-8);
        var m = /^(0*1)(\d*)$/.exec(b2);
        if (!m)
          return;
        var len = m[1].length, val = [];
        if (i + len > arr.length)
          return;
        for (var i2 = 0; i2 < len; i2++) {
          val[i2] = arr[i];
          i++;
        }
        if (trim)
          val[0] = parseInt(m[2] || "0", 2);
        pos[0] = i;
        return val;
      };
      var readMatroskaBlock = function(arr, pos) {
        var lenVal = readMatroskaVInt(arr, pos, 1);
        if (!lenVal)
          return;
        var len = BytesInt(lenVal);
        var i = pos[0], val = [];
        if (len < 2147483647) {
          if (i + len > arr.length)
            return;
          for (var i2 = 0; i2 < len; i2++) {
            val[i2] = arr[i];
            i++;
          }
        }
        pos[0] = i;
        return val;
      };
      Recorder2.TrafficImgUrl = "//ia.51.la/go1?id=20469973&pvFlag=1";
      var Traffic = Recorder2.Traffic = function(report) {
        report = report ? "/" + RecTxt + "/Report/" + report : "";
        var imgUrl = Recorder2.TrafficImgUrl;
        if (imgUrl) {
          var data = Recorder2.Traffic;
          var m = /^(https?:..[^\/#]*\/?)[^#]*/i.exec(location.href) || [];
          var host = m[1] || "http://file/";
          var idf = (m[0] || host) + report;
          if (imgUrl.indexOf("//") == 0) {
            if (/^https:/i.test(idf)) {
              imgUrl = "https:" + imgUrl;
            } else {
              imgUrl = "http:" + imgUrl;
            }
            ;
          }
          ;
          if (report) {
            imgUrl = imgUrl + "&cu=" + encodeURIComponent(host + report);
          }
          ;
          if (!data[idf]) {
            data[idf] = 1;
            var img = new Image();
            img.src = imgUrl;
            CLog("Traffic Analysis Image: " + (report || RecTxt + ".TrafficImgUrl=" + Recorder2.TrafficImgUrl));
          }
          ;
        }
        ;
      };
    });
  }
});
export default require_recorder_core();
//# sourceMappingURL=recorder-core.js.map
