{
  "version": 3,
  "sources": ["../../recorder-core/src/engine/wav.js"],
  "sourcesContent": ["/*\nwav编码器+编码引擎\nhttps://github.com/xiangyuecn/Recorder\n\n当然最佳推荐使用mp3、wav格式，代码也是优先照顾这两种格式\n浏览器支持情况\nhttps://developer.mozilla.org/en-US/docs/Web/HTML/Supported_media_formats\n\n编码原理：给pcm数据加上一个44字节的wav头即成wav文件；pcm数据就是Recorder中的buffers原始数据（重新采样），16位时为LE小端模式（Little Endian），实质上是未经过任何编码处理\n\n注意：其他wav编码器可能不是44字节的头，要从任意wav文件中提取pcm数据，请参考：assets/runtime-codes/fragment.decode.wav.js\n*/\n(function(){\n\"use strict\";\n\nRecorder.prototype.enc_wav={\n\tstable:true,fast:true\n\t,testmsg:\"支持位数8位、16位（填在比特率里面），采样率取值无限制；此编码器仅在pcm数据前加了一个44字节的wav头，编码出来的16位wav文件去掉开头的44字节即可得到pcm（注：其他wav编码器可能不是44字节）\"\n};\nRecorder.prototype.wav=function(res,True,False){\n\t\tvar This=this,set=This.set\n\t\t\t,size=res.length\n\t\t\t,sampleRate=set.sampleRate\n\t\t\t,bitRate=set.bitRate==8?8:16;\n\t\t\n\t\t//编码数据 https://github.com/mattdiamond/Recorderjs https://www.cnblogs.com/blqw/p/3782420.html https://www.cnblogs.com/xiaoqi/p/6993912.html\n\t\tvar dataLength=size*(bitRate/8);\n\t\tvar buffer=new ArrayBuffer(44+dataLength);\n\t\tvar data=new DataView(buffer);\n\t\t\n\t\tvar offset=0;\n\t\tvar writeString=function(str){\n\t\t\tfor (var i=0;i<str.length;i++,offset++) {\n\t\t\t\tdata.setUint8(offset,str.charCodeAt(i));\n\t\t\t};\n\t\t};\n\t\tvar write16=function(v){\n\t\t\tdata.setUint16(offset,v,true);\n\t\t\toffset+=2;\n\t\t};\n\t\tvar write32=function(v){\n\t\t\tdata.setUint32(offset,v,true);\n\t\t\toffset+=4;\n\t\t};\n\t\t\n\t\t/* RIFF identifier */\n\t\twriteString('RIFF');\n\t\t/* RIFF chunk length */\n\t\twrite32(36+dataLength);\n\t\t/* RIFF type */\n\t\twriteString('WAVE');\n\t\t/* format chunk identifier */\n\t\twriteString('fmt ');\n\t\t/* format chunk length */\n\t\twrite32(16);\n\t\t/* sample format (raw) */\n\t\twrite16(1);\n\t\t/* channel count */\n\t\twrite16(1);\n\t\t/* sample rate */\n\t\twrite32(sampleRate);\n\t\t/* byte rate (sample rate * block align) */\n\t\twrite32(sampleRate*(bitRate/8));// *1 声道\n\t\t/* block align (channel count * bytes per sample) */\n\t\twrite16(bitRate/8);// *1 声道\n\t\t/* bits per sample */\n\t\twrite16(bitRate);\n\t\t/* data chunk identifier */\n\t\twriteString('data');\n\t\t/* data chunk length */\n\t\twrite32(dataLength);\n\t\t// 写入采样数据\n\t\tif(bitRate==8) {\n\t\t\tfor(var i=0;i<size;i++,offset++) {\n\t\t\t\t//16转8据说是雷霄骅的 https://blog.csdn.net/sevennight1989/article/details/85376149 细节比blqw的按比例的算法清晰点，虽然都有明显杂音\n\t\t\t\tvar val=(res[i]>>8)+128;\n\t\t\t\tdata.setInt8(offset,val,true);\n\t\t\t};\n\t\t}else{\n\t\t\tfor (var i=0;i<size;i++,offset+=2){\n\t\t\t\tdata.setInt16(offset,res[i],true);\n\t\t\t};\n\t\t};\n\t\t\n\t\t\n\t\tTrue(new Blob([data.buffer],{type:\"audio/wav\"}));\n\t}\n})();"],
  "mappings": ";CAYC,WAAU;AACX;AAEA,WAAS,UAAU,UAAQ;AAAA,IAC1B,QAAO;AAAA,IAAK,MAAK;AAAA,IAChB,SAAQ;AAAA,EACV;AACA,WAAS,UAAU,MAAI,SAAS,KAAI,MAAK,OAAM;AAC7C,QAAI,OAAK,MAAK,MAAI,KAAK,KACrB,OAAK,IAAI,QACT,aAAW,IAAI,YACf,UAAQ,IAAI,WAAS,IAAE,IAAE;AAG3B,QAAI,aAAW,QAAM,UAAQ;AAC7B,QAAI,SAAO,IAAI,YAAY,KAAG,UAAU;AACxC,QAAI,OAAK,IAAI,SAAS,MAAM;AAE5B,QAAI,SAAO;AACX,QAAI,cAAY,SAAS,KAAI;AAC5B,eAASA,KAAE,GAAEA,KAAE,IAAI,QAAOA,MAAI,UAAU;AACvC,aAAK,SAAS,QAAO,IAAI,WAAWA,EAAC,CAAC;AAAA,MACvC;AAAC;AAAA,IACF;AACA,QAAI,UAAQ,SAAS,GAAE;AACtB,WAAK,UAAU,QAAO,GAAE,IAAI;AAC5B,gBAAQ;AAAA,IACT;AACA,QAAI,UAAQ,SAAS,GAAE;AACtB,WAAK,UAAU,QAAO,GAAE,IAAI;AAC5B,gBAAQ;AAAA,IACT;AAGA,gBAAY,MAAM;AAElB,YAAQ,KAAG,UAAU;AAErB,gBAAY,MAAM;AAElB,gBAAY,MAAM;AAElB,YAAQ,EAAE;AAEV,YAAQ,CAAC;AAET,YAAQ,CAAC;AAET,YAAQ,UAAU;AAElB,YAAQ,cAAY,UAAQ,EAAE;AAE9B,YAAQ,UAAQ,CAAC;AAEjB,YAAQ,OAAO;AAEf,gBAAY,MAAM;AAElB,YAAQ,UAAU;AAElB,QAAG,WAAS,GAAG;AACd,eAAQ,IAAE,GAAE,IAAE,MAAK,KAAI,UAAU;AAEhC,YAAI,OAAK,IAAI,CAAC,KAAG,KAAG;AACpB,aAAK,QAAQ,QAAO,KAAI,IAAI;AAAA,MAC7B;AAAC;AAAA,IACF,OAAK;AACJ,eAAS,IAAE,GAAE,IAAE,MAAK,KAAI,UAAQ,GAAE;AACjC,aAAK,SAAS,QAAO,IAAI,CAAC,GAAE,IAAI;AAAA,MACjC;AAAC;AAAA,IACF;AAAC;AAGD,SAAK,IAAI,KAAK,CAAC,KAAK,MAAM,GAAE,EAAC,MAAK,YAAW,CAAC,CAAC;AAAA,EAChD;AACD,GAAG;",
  "names": ["i"]
}
